const vscode = require('vscode');
const axios = require('axios');

const BASE_URL = 'http://54.180.117.184:8000';
const GAUGE_UPDATE_INTERVAL = 1000; // 1ì´ˆ
const RESET_TIME = 10000; // 10ì´ˆ

// ì „ì—­ ë³€ìˆ˜ë¡œ ê²Œì´ì§€ë°” ê´€ë ¨ ë³€ìˆ˜ë“¤ì„ ì„ ì–¸
let gaugeBarItem = null;
let gaugeUpdateInterval = null;
let currentQuestionCount = 0;
let previousValue = 0;
let message50Shown = false;
let message75Shown = false;
let message100Shown = false;

// ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
async function showMessages(messages, type = 'info') {
    for (let i = messages.length - 1; i >= 0; i--) {
        if (type === 'warning') {
            await vscode.window.showWarningMessage(messages[i]);
        } else {
            await vscode.window.showInformationMessage(messages[i]);
        }
        await new Promise(resolve => setTimeout(resolve, 500));
    }
}

// ê²Œì´ì§€ë°” ìƒì„± í•¨ìˆ˜
function createGaugeBar() {
    if (gaugeBarItem) {
        gaugeBarItem.dispose();
        gaugeBarItem = null;
    }

    gaugeBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 10000);
    gaugeBarItem.text = '$(loading~spin)';
    gaugeBarItem.show();

    // ê²Œì´ì§€ë°” ì—…ë°ì´íŠ¸ ì‹œì‘
    if (gaugeUpdateInterval) {
        clearInterval(gaugeUpdateInterval);
    }
    gaugeUpdateInterval = setInterval(updateGauge, GAUGE_UPDATE_INTERVAL);
    updateGauge();

    return gaugeBarItem;
}

// ê²Œì´ì§€ë°” ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updateGauge() {
    try {
        const response = await axios.get(`${BASE_URL}/get_question`);
        const value = Number(response.data.current_count);
        
        if (isNaN(value)) {
            gaugeBarItem.text = 'ë°ì´í„° ì˜¤ë¥˜';
            return;
        }

        currentQuestionCount = value;
        const normalizedValue = Math.min(Math.max(value / 37, 0), 1);
        const filledBlocks = Math.floor(normalizedValue * 20);
        const emptyBlocks = 20 - filledBlocks;
        gaugeBarItem.text = `${filledBlocks > 0 ? 'â–ˆ'.repeat(filledBlocks) : ''}${emptyBlocks > 0 ? 'â–‘'.repeat(emptyBlocks) : ''}`;
        gaugeBarItem.color = '#E74C3C'; // ìì—°ìŠ¤ëŸ¬ìš´ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì„¤ì •

        // ë©”ì‹œì§€ í‘œì‹œ ë¡œì§
        if (normalizedValue >= 1 && value > previousValue && !message100Shown) {
            await showMessages([
                'ğŸš¨ ê°•ì‚¬ë‹˜! ğŸš¨',
                'ë¨¸ë¦¬ê°€ í„°ì§ˆ ê²ƒ ê°™ì•„ìš”...',
                'ì ê¹ ì‰¬ì—ˆë‹¤ í• ê¹Œìš”...? ã…ã…'
            ], 'warning');
            message100Shown = true;
        }
        else if (normalizedValue > 0.75 && value > previousValue && !message75Shown) {
            await showMessages([
                'ğŸ˜­ ê°•ì‚¬ë‹˜ ì‚´ë ¤ì£¼ì„¸ìš”... ğŸ˜­',
                'ì—¬ê¸°ë§Œ ë„˜ì–´ê°€ë©´ ì˜ í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ì•„ìš” ã… ã… ',
                'í˜„ì¬ ì˜ ëª¨ë¥´ê² ëŠ” í•™ìƒ : ' + value + 'ëª…'
            ], 'warning');
            message75Shown = true;
        }
        else if (normalizedValue > 0.5 && value > previousValue && !message50Shown) {
            await showMessages([
                'ğŸ’¡ ê°•ì‚¬ë‹˜ ì¡°ê¸ˆ ë²„ê±°ì›Œìš”... ğŸ’¡',
                'í•œ ë²ˆë§Œ ë‹¤ì‹œ ì„¤ëª…í•´ ì£¼ì‹œë©´ ì´í•´ë  ê²ƒ ê°™ì•„ìš”!'
            ]);
            message50Shown = true;
        }

        previousValue = value;
    } catch {
        gaugeBarItem.text = 'ê²Œì´ì§€ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨';
    }
}

function activate(context) {
    // ì˜¤ë¥¸ìª½ ìƒíƒœë°” ë²„íŠ¼ ìƒì„±
    let statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 1);
    statusBarItem.text = '$(circle-outline)';
    statusBarItem.color = '#00FF00';
    statusBarItem.tooltip = 'ëª°?ë£¨';
    statusBarItem.command = 'kda-extension.question';
    statusBarItem.show();

    // íƒ€ì´ë¨¸ ë³€ìˆ˜
    let questionTimer = null;

    // ì§ˆë¬¸í•˜ê¸° ëª…ë ¹ ë“±ë¡
    let disposable = vscode.commands.registerCommand('kda-extension.question', async () => {
        try {
            if (statusBarItem.text === '$(question)') {
                vscode.window.showInformationMessage('?');
                return;
            }

            await axios.post(`${BASE_URL}/add_question`);
            
            statusBarItem.text = '$(question)';
            statusBarItem.color = '#FFFF00';
            
            if (questionTimer) {
                clearTimeout(questionTimer);
            }
            questionTimer = setTimeout(() => {
                statusBarItem.text = '$(circle-outline)';
                statusBarItem.color = '#00FF00';
            }, RESET_TIME);
        } catch {
            vscode.window.showErrorMessage('ì˜¤ë¥˜ë°œìƒ.. slackìœ¼ë¡œ ë¬¸ì˜ ë°”ëŒ');
        }
    });

    // ê°œë°œìš© ë¬´ì œí•œ post ìš”ì²­ ëª…ë ¹ ë“±ë¡
    let devDisposable = vscode.commands.registerCommand('kda-extension.dev-post', async () => {
        try {
            await axios.post(`${BASE_URL}/add_question`);
            vscode.window.showInformationMessage('ê°œë°œìš© post ìš”ì²­ ì„±ê³µ');
        } catch {
            vscode.window.showErrorMessage('ì˜¤ë¥˜ë°œìƒ.. slackìœ¼ë¡œ ë¬¸ì˜ ë°”ëŒ');
        }
    });

    // í˜„ì¬ ì§ˆë¬¸ ìˆ˜ í™•ì¸ ëª…ë ¹ ë“±ë¡
    let showCountDisposable = vscode.commands.registerCommand('kda-extension.show-question-count', () => {
        vscode.window.showInformationMessage(`í˜„ì¬ ì§ˆë¬¸ ìˆ˜: ${currentQuestionCount}ê°œ`);
    });

    // ê²Œì´ì§€ë°” ìƒì„± ëª…ë ¹ ë“±ë¡
    let createGaugeDisposable = vscode.commands.registerCommand('kda-extension.create-gauge', () => {
        if (!gaugeBarItem) {
            createGaugeBar();
            vscode.window.showInformationMessage('ê²Œì´ì§€ë°”ê°€ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.');
        } else {
            // ê²Œì´ì§€ë°”ê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš° ì œê±°
            gaugeBarItem.dispose();
            gaugeBarItem = null;
            if (gaugeUpdateInterval) {
                clearInterval(gaugeUpdateInterval);
                gaugeUpdateInterval = null;
            }
            vscode.window.showInformationMessage('ê²Œì´ì§€ë°”ê°€ ìˆ¨ê²¨ì¡ŒìŠµë‹ˆë‹¤.');
        }
    });

    // contextì— ë“±ë¡
    context.subscriptions.push(
        statusBarItem,
        gaugeBarItem,
        disposable,
        showCountDisposable,
        devDisposable,
        createGaugeDisposable
    );
}

function deactivate() {
    if (gaugeBarItem) {
        gaugeBarItem.dispose();
    }
    if (gaugeUpdateInterval) {
        clearInterval(gaugeUpdateInterval);
    }
}

module.exports = {
    activate,
    deactivate
};